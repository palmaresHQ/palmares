import { getDefaultStd } from '@palmares/core';
import { adapterModels } from '@palmares/databases';

import type { ModelOptionsType } from '@palmares/databases';

export const models = adapterModels({
  // eslint-disable-next-line ts/require-await
  translateOptions: async (_engine, modelName, options): Promise<object> => {
    const optionsWithConjunctiveIndexes = options as typeof options & { conjunctiveIndexes: string[] };
    if (options.indexes)
      optionsWithConjunctiveIndexes.conjunctiveIndexes = options.indexes.map((index) => {
        const indexFields = index.fields.join('_');
        const indexAsCamel = indexFields.toLowerCase().replace(/(^([a-z]+))|([-_][a-z])/g, (group) => {
          const groupWithoutDash = group.replace(/[-_]/, '');
          const firstLetterUpper = groupWithoutDash[0].toUpperCase();
          return firstLetterUpper + groupWithoutDash.slice(1);
        });
        const indexFieldsForOnClause = index.fields.map((field) => `table.${field}`).join(', ');
        return `  ${modelName.slice(0, 1).toLowerCase() + modelName.slice(1)}${indexAsCamel}:  d.${
          index.unique ? 'uniqueIndex' : 'index'
        }('${options.tableName || modelName}_${indexFields}').on(${indexFieldsForOnClause})`;
      });

    return {
      ...options
    };
  },

  translate: async (
    _engine,
    _modelName,
    _model,
    _fieldEntriesOfModel,
    _modelOptions,
    _customModelOptions,
    defaultTranslateCallback: () => Promise<{ options: any; fields: any }>,
    _,
    __
  ): Promise<{
    fields: Record<string, string>;
    options: ModelOptionsType;
  }> => {
    const { options: translatedOptions, fields: translatedAttributes } = await defaultTranslateCallback();
    return {
      fields: translatedAttributes,
      options: translatedOptions
    };
  },

  afterModelsTranslation: async (engine, models): Promise<[string, any][]> => {
    let fileContent = '';
    const std = getDefaultStd();
    const [cwd, directoryName] = await Promise.all([std.os.cwd(), std.files.dirname(engine.instance.output)]);
    const [folderName, locationToRequire] = await Promise.all([
      std.files.join(cwd, directoryName),
      std.files.join(cwd, engine.instance.output)
    ]);
    const imports = new Set([
      `/** Automatically generated by @palmares/drizzle-engine on ${new Date().toISOString()} */ \n`,
      `import * as d from '@palmares/drizzle-adapter/${
        engine.instance.mainType === 'postgres' ? 'pg' : engine.instance.mainType === 'sqlite' ? 'sqlite' : 'mysql'
      }-core';`
    ]);

    const relationships = new Map<string, Record<string, string>>();
    const tableType =
      engine.instance.mainType === 'postgres'
        ? 'pgTable'
        : engine.instance.mainType === 'sqlite'
          ? 'sqliteTable'
          : 'mysqlTable';
    for (let i = 0; i < models.length; i++) {
      const [modelName, model] = models[i];

      for (const [relationModelName, relations] of Object.entries(model.options.relationships || {})) {
        relationships.set(relationModelName, {
          ...(relationships.get(relationModelName) || {}),
          ...(relations as any)
        });
      }

      const indexesOfModel = model.options.drizzleIndexes || [];
      const entriesOfFields = Object.entries(model.fields);
      const hasEnums = (model.options.enums || []).length > 0;

      if (model.options.imports)
        Array.from(model.options.imports || []).forEach((importString) => imports.add(importString as string));

      const modelContentStarter = hasEnums
        ? model.options.enums.map((enumColumn: string) => enumColumn).join('\n') + '\n\n'
        : '';
      const modelContent = `${modelContentStarter}export const ${modelName} = d.${
        tableType
      }('${model.options.tableName}', {\n${entriesOfFields
        .map(([fieldName, fieldString]) => `  ${fieldName}: ${fieldString}`)
        .join(',\n')}\n}${
        indexesOfModel.length > 0
          ? `, (table) => ({\n` +
            `${indexesOfModel
              .map(
                (index: { fieldName: string; databaseName: string; unique: boolean }) =>
                  `  ${index.fieldName}Idx: d.${index.unique ? 'uniqueIndex' : 'index'}('${
                    model.options.tableName
                  }_${index.databaseName}_idx').on(table.${index.fieldName})`
              )
              .concat(model.options.conjunctiveIndexes || [])
              .join(',\n')}\n})`
          : ''
      });\n\n`;
      fileContent += modelContent;
      models[i] = [
        modelName,
        async () => {
          try {
            return Promise.resolve(require(locationToRequire)[modelName]);
          } catch (e) {
            return (await import(locationToRequire))[modelName];
          }
        }
      ];
    }
    if (relationships.size > 0) imports.add(`import * as drzl from '@palmares/drizzle-adapter/drizzle';`);

    for (const [modelName, relations] of relationships.entries()) {
      fileContent += `export const ${modelName}Relations = drzl.relations(${modelName}, (args) => ({\n${Object.entries(
        relations
      )
        .map(([relationName, relation]) => `  ${relationName}: ${relation}`)
        .join(',\n')}\n}));\n\n`;
    }

    await std.files.makeDirectory(folderName);
    await std.files.writeFile(locationToRequire, `${Array.from(imports).join('\n')}\n\n${fileContent}`);

    const modelsImported = await Promise.all(models.map(async ([modelName, model]) => [modelName, await model()]));
    return modelsImported as [string, any][];
  }
});
